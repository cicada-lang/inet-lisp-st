[vm] [maybe] op.get -- the same as refactoring call to ref and apply

- get a def:
  - get a function_def will push the const function to stack
  - get a node_def will push a new function to stack

[lang] execute -- handle stmt_define_function -- call compile_function
[lang] compile_function
[lang] compile_exp_list
[lang] compile_exp

[lang] execute -- handle stmt_compute_exp -- call compile_function and run

[lang] parse_define_rule

[lang] pattern_t
[lang] stmt_define_rule -- need pattern

[lang] apply_function -- handle arity

# later

[example] examples/cellular-automata.lisp -- 1997-interaction-combinators.pdf
[example] examples/lambda.lisp -- use interaction combinators to implement lambda
[example] examples/turing.lisp -- coding turing machine -- 2008-the-annotated-turing.djvu

# primitive value

[design] node ports can store any value -- not only wire, but also primitive values
[design] the most important primitive value is function (closure)
[design] write `list-map` as example that uses function
[design] use explicit `copy` -- keep linear variable like simple

# debug

[debug] 尝试使用真实的物理学来实现 force
[debug] `node_physics_simulate` -- move by `velocity` and clear `force` for every `node_model`
[debug] remove `node_physics_fake_simulate`

# vm

[vm] mod -- change rule_list to rule_hash -- what should be the key?

# module system

支持简单的 import name，同时支持修改 name 以避免冲突

# parallelism

learn linux thread
shared memory parallel execution of inet
projects/others/HigherOrderCO/HVM/paper/HVM2.pdf
